// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: debugger.proto

#ifndef PROTOBUF_debugger_2eproto__INCLUDED
#define PROTOBUF_debugger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_debugger_2eproto();
void protobuf_AssignDesc_debugger_2eproto();
void protobuf_ShutdownFile_debugger_2eproto();

class Version;
class AnnounceDetails;
class ExecutionDetails;
class DebugCommand;
class ClientMessage;
class ProcessInfo;
class FunctionArgument;
class FunctionCall;
class GLFunction;
class GLFunctions;
class ServerMessage;

enum ExecutionDetails_Operation {
  ExecutionDetails_Operation_CONTINUE = 0,
  ExecutionDetails_Operation_HALT = 1,
  ExecutionDetails_Operation_STEP = 2,
  ExecutionDetails_Operation_TO_SHADER_SWITCH = 3,
  ExecutionDetails_Operation_TO_DRAW_CALL = 4,
  ExecutionDetails_Operation_TO_USER_DEFINED = 5
};
bool ExecutionDetails_Operation_IsValid(int value);
const ExecutionDetails_Operation ExecutionDetails_Operation_Operation_MIN = ExecutionDetails_Operation_CONTINUE;
const ExecutionDetails_Operation ExecutionDetails_Operation_Operation_MAX = ExecutionDetails_Operation_TO_USER_DEFINED;
const int ExecutionDetails_Operation_Operation_ARRAYSIZE = ExecutionDetails_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecutionDetails_Operation_descriptor();
inline const ::std::string& ExecutionDetails_Operation_Name(ExecutionDetails_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecutionDetails_Operation_descriptor(), value);
}
inline bool ExecutionDetails_Operation_Parse(
    const ::std::string& name, ExecutionDetails_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutionDetails_Operation>(
    ExecutionDetails_Operation_descriptor(), name, value);
}
enum DebugCommand_Type {
  DebugCommand_Type_DONE = 1,
  DebugCommand_Type_CALL_FUNCTION = 2,
  DebugCommand_Type_RECORD_CALL = 3,
  DebugCommand_Type_CALL_ORIGFUNCTION = 4,
  DebugCommand_Type_EXECUTE = 5,
  DebugCommand_Type_ALLOC_MEM = 6,
  DebugCommand_Type_FREE_MEM = 7,
  DebugCommand_Type_READ_RENDER_BUFFER = 8,
  DebugCommand_Type_CLEAR_RENDER_BUFFER = 9,
  DebugCommand_Type_SET_DBG_TARGET = 10,
  DebugCommand_Type_RESTORE_RENDER_TARGET = 11,
  DebugCommand_Type_START_RECORDING = 12,
  DebugCommand_Type_REPLAY = 13,
  DebugCommand_Type_END_REPLAY = 14,
  DebugCommand_Type_STORE_ACTIVE_SHADER = 15,
  DebugCommand_Type_RESTORE_ACTIVE_SHADER = 16,
  DebugCommand_Type_SET_DBG_SHADER = 17,
  DebugCommand_Type_GET_SHADER_CODE = 18,
  DebugCommand_Type_SHADER_STEP = 19,
  DebugCommand_Type_SAVE_AND_INTERRUPT_QUERIES = 20,
  DebugCommand_Type_RESTART_QUERIES = 21,
  DebugCommand_Type_CALL_ORIGFUNCTION_AND_PROCEED = 22
};
bool DebugCommand_Type_IsValid(int value);
const DebugCommand_Type DebugCommand_Type_Type_MIN = DebugCommand_Type_DONE;
const DebugCommand_Type DebugCommand_Type_Type_MAX = DebugCommand_Type_CALL_ORIGFUNCTION_AND_PROCEED;
const int DebugCommand_Type_Type_ARRAYSIZE = DebugCommand_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugCommand_Type_descriptor();
inline const ::std::string& DebugCommand_Type_Name(DebugCommand_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugCommand_Type_descriptor(), value);
}
inline bool DebugCommand_Type_Parse(
    const ::std::string& name, DebugCommand_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugCommand_Type>(
    DebugCommand_Type_descriptor(), name, value);
}
enum ClientMessage_Type {
  ClientMessage_Type_ANNOUNCE = 0,
  ClientMessage_Type_PROCESS_INFO = 1,
  ClientMessage_Type_GL_FUNCTIONS = 2,
  ClientMessage_Type_FUNCTION_CALL = 3,
  ClientMessage_Type_EXECUTION = 4,
  ClientMessage_Type_DEBUG_COMMAND = 5
};
bool ClientMessage_Type_IsValid(int value);
const ClientMessage_Type ClientMessage_Type_Type_MIN = ClientMessage_Type_ANNOUNCE;
const ClientMessage_Type ClientMessage_Type_Type_MAX = ClientMessage_Type_DEBUG_COMMAND;
const int ClientMessage_Type_Type_ARRAYSIZE = ClientMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMessage_Type_descriptor();
inline const ::std::string& ClientMessage_Type_Name(ClientMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMessage_Type_descriptor(), value);
}
inline bool ClientMessage_Type_Parse(
    const ::std::string& name, ClientMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMessage_Type>(
    ClientMessage_Type_descriptor(), name, value);
}
enum DebugType {
  CHAR = 0,
  UNSIGNED_CHAR = 1,
  SHORT = 2,
  UNSIGNED_SHORT = 3,
  INT = 4,
  UNSIGNED_INT = 5,
  LONG_INT = 6,
  UNSIGNED_LONG_INT = 7,
  LONG_LONG_INT = 8,
  UNSIGNED_LONG_LONG_INT = 9,
  FLOAT = 10,
  DOUBLE = 11,
  LONGDOUBLE = 12,
  POINTER = 13,
  STRUCT = 14,
  BITFIELD = 15,
  ENUM = 16,
  BOOL = 17
};
bool DebugType_IsValid(int value);
const DebugType DebugType_MIN = CHAR;
const DebugType DebugType_MAX = BOOL;
const int DebugType_ARRAYSIZE = DebugType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugType_descriptor();
inline const ::std::string& DebugType_Name(DebugType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugType_descriptor(), value);
}
inline bool DebugType_Parse(
    const ::std::string& name, DebugType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugType>(
    DebugType_descriptor(), name, value);
}
enum ErrorCode {
  NONE = 0,
  HEADER_MISMATCH = 1,
  VERSION_MISMATCH = 2,
  AUTH_FAILED = 3,
  GENERIC_ERROR = 4
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = NONE;
const ErrorCode ErrorCode_MAX = GENERIC_ERROR;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
inline const ::std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorCode_descriptor(), value);
}
inline bool ErrorCode_Parse(
    const ::std::string& name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
// ===================================================================

class Version : public ::google::protobuf::Message {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();

  void Swap(Version* other);

  // implements Message ----------------------------------------------

  Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 major = 1;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::int32 major() const;
  inline void set_major(::google::protobuf::int32 value);

  // required int32 minor = 2;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::int32 minor() const;
  inline void set_minor(::google::protobuf::int32 value);

  // required int32 revision = 3;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 3;
  inline ::google::protobuf::int32 revision() const;
  inline void set_revision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.Version)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 major_;
  ::google::protobuf::int32 minor_;
  ::google::protobuf::int32 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceDetails : public ::google::protobuf::Message {
 public:
  AnnounceDetails();
  virtual ~AnnounceDetails();

  AnnounceDetails(const AnnounceDetails& from);

  inline AnnounceDetails& operator=(const AnnounceDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnounceDetails& default_instance();

  void Swap(AnnounceDetails* other);

  // implements Message ----------------------------------------------

  AnnounceDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnnounceDetails& from);
  void MergeFrom(const AnnounceDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string client_name = 2;
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 2;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // required .proto.Version version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::proto::Version& version() const;
  inline ::proto::Version* mutable_version();
  inline ::proto::Version* release_version();
  inline void set_allocated_version(::proto::Version* version);

  // @@protoc_insertion_point(class_scope:proto.AnnounceDetails)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_client_name();
  inline void clear_has_client_name();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* client_name_;
  ::proto::Version* version_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static AnnounceDetails* default_instance_;
};
// -------------------------------------------------------------------

class ExecutionDetails : public ::google::protobuf::Message {
 public:
  ExecutionDetails();
  virtual ~ExecutionDetails();

  ExecutionDetails(const ExecutionDetails& from);

  inline ExecutionDetails& operator=(const ExecutionDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutionDetails& default_instance();

  void Swap(ExecutionDetails* other);

  // implements Message ----------------------------------------------

  ExecutionDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutionDetails& from);
  void MergeFrom(const ExecutionDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExecutionDetails_Operation Operation;
  static const Operation CONTINUE = ExecutionDetails_Operation_CONTINUE;
  static const Operation HALT = ExecutionDetails_Operation_HALT;
  static const Operation STEP = ExecutionDetails_Operation_STEP;
  static const Operation TO_SHADER_SWITCH = ExecutionDetails_Operation_TO_SHADER_SWITCH;
  static const Operation TO_DRAW_CALL = ExecutionDetails_Operation_TO_DRAW_CALL;
  static const Operation TO_USER_DEFINED = ExecutionDetails_Operation_TO_USER_DEFINED;
  static inline bool Operation_IsValid(int value) {
    return ExecutionDetails_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    ExecutionDetails_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    ExecutionDetails_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    ExecutionDetails_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return ExecutionDetails_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return ExecutionDetails_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return ExecutionDetails_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.ExecutionDetails.Operation operation = 1;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 1;
  inline ::proto::ExecutionDetails_Operation operation() const;
  inline void set_operation(::proto::ExecutionDetails_Operation value);

  // optional .proto.FunctionCall call = 3;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 3;
  inline const ::proto::FunctionCall& call() const;
  inline ::proto::FunctionCall* mutable_call();
  inline ::proto::FunctionCall* release_call();
  inline void set_allocated_call(::proto::FunctionCall* call);

  // @@protoc_insertion_point(class_scope:proto.ExecutionDetails)
 private:
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_call();
  inline void clear_has_call();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::FunctionCall* call_;
  int operation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static ExecutionDetails* default_instance_;
};
// -------------------------------------------------------------------

class DebugCommand : public ::google::protobuf::Message {
 public:
  DebugCommand();
  virtual ~DebugCommand();

  DebugCommand(const DebugCommand& from);

  inline DebugCommand& operator=(const DebugCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugCommand& default_instance();

  void Swap(DebugCommand* other);

  // implements Message ----------------------------------------------

  DebugCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugCommand& from);
  void MergeFrom(const DebugCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DebugCommand_Type Type;
  static const Type DONE = DebugCommand_Type_DONE;
  static const Type CALL_FUNCTION = DebugCommand_Type_CALL_FUNCTION;
  static const Type RECORD_CALL = DebugCommand_Type_RECORD_CALL;
  static const Type CALL_ORIGFUNCTION = DebugCommand_Type_CALL_ORIGFUNCTION;
  static const Type EXECUTE = DebugCommand_Type_EXECUTE;
  static const Type ALLOC_MEM = DebugCommand_Type_ALLOC_MEM;
  static const Type FREE_MEM = DebugCommand_Type_FREE_MEM;
  static const Type READ_RENDER_BUFFER = DebugCommand_Type_READ_RENDER_BUFFER;
  static const Type CLEAR_RENDER_BUFFER = DebugCommand_Type_CLEAR_RENDER_BUFFER;
  static const Type SET_DBG_TARGET = DebugCommand_Type_SET_DBG_TARGET;
  static const Type RESTORE_RENDER_TARGET = DebugCommand_Type_RESTORE_RENDER_TARGET;
  static const Type START_RECORDING = DebugCommand_Type_START_RECORDING;
  static const Type REPLAY = DebugCommand_Type_REPLAY;
  static const Type END_REPLAY = DebugCommand_Type_END_REPLAY;
  static const Type STORE_ACTIVE_SHADER = DebugCommand_Type_STORE_ACTIVE_SHADER;
  static const Type RESTORE_ACTIVE_SHADER = DebugCommand_Type_RESTORE_ACTIVE_SHADER;
  static const Type SET_DBG_SHADER = DebugCommand_Type_SET_DBG_SHADER;
  static const Type GET_SHADER_CODE = DebugCommand_Type_GET_SHADER_CODE;
  static const Type SHADER_STEP = DebugCommand_Type_SHADER_STEP;
  static const Type SAVE_AND_INTERRUPT_QUERIES = DebugCommand_Type_SAVE_AND_INTERRUPT_QUERIES;
  static const Type RESTART_QUERIES = DebugCommand_Type_RESTART_QUERIES;
  static const Type CALL_ORIGFUNCTION_AND_PROCEED = DebugCommand_Type_CALL_ORIGFUNCTION_AND_PROCEED;
  static inline bool Type_IsValid(int value) {
    return DebugCommand_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DebugCommand_Type_Type_MIN;
  static const Type Type_MAX =
    DebugCommand_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DebugCommand_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return DebugCommand_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return DebugCommand_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return DebugCommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.DebugCommand.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::DebugCommand_Type type() const;
  inline void set_type(::proto::DebugCommand_Type value);

  // @@protoc_insertion_point(class_scope:proto.DebugCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static DebugCommand* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  void Swap(ClientMessage* other);

  // implements Message ----------------------------------------------

  ClientMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientMessage_Type Type;
  static const Type ANNOUNCE = ClientMessage_Type_ANNOUNCE;
  static const Type PROCESS_INFO = ClientMessage_Type_PROCESS_INFO;
  static const Type GL_FUNCTIONS = ClientMessage_Type_GL_FUNCTIONS;
  static const Type FUNCTION_CALL = ClientMessage_Type_FUNCTION_CALL;
  static const Type EXECUTION = ClientMessage_Type_EXECUTION;
  static const Type DEBUG_COMMAND = ClientMessage_Type_DEBUG_COMMAND;
  static inline bool Type_IsValid(int value) {
    return ClientMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientMessage_Type_Type_MIN;
  static const Type Type_MAX =
    ClientMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.ClientMessage.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::ClientMessage_Type type() const;
  inline void set_type(::proto::ClientMessage_Type value);

  // required uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint64 thread_id = 3;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 3;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);

  // optional .proto.AnnounceDetails announce = 4;
  inline bool has_announce() const;
  inline void clear_announce();
  static const int kAnnounceFieldNumber = 4;
  inline const ::proto::AnnounceDetails& announce() const;
  inline ::proto::AnnounceDetails* mutable_announce();
  inline ::proto::AnnounceDetails* release_announce();
  inline void set_allocated_announce(::proto::AnnounceDetails* announce);

  // optional .proto.ExecutionDetails execution = 5;
  inline bool has_execution() const;
  inline void clear_execution();
  static const int kExecutionFieldNumber = 5;
  inline const ::proto::ExecutionDetails& execution() const;
  inline ::proto::ExecutionDetails* mutable_execution();
  inline ::proto::ExecutionDetails* release_execution();
  inline void set_allocated_execution(::proto::ExecutionDetails* execution);

  // optional .proto.DebugCommand command = 6;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 6;
  inline const ::proto::DebugCommand& command() const;
  inline ::proto::DebugCommand* mutable_command();
  inline ::proto::DebugCommand* release_command();
  inline void set_allocated_command(::proto::DebugCommand* command);

  // @@protoc_insertion_point(class_scope:proto.ClientMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_announce();
  inline void clear_has_announce();
  inline void set_has_execution();
  inline void clear_has_execution();
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 thread_id_;
  ::proto::AnnounceDetails* announce_;
  ::proto::ExecutionDetails* execution_;
  ::proto::DebugCommand* command_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class ProcessInfo : public ::google::protobuf::Message {
 public:
  ProcessInfo();
  virtual ~ProcessInfo();

  ProcessInfo(const ProcessInfo& from);

  inline ProcessInfo& operator=(const ProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessInfo& default_instance();

  void Swap(ProcessInfo* other);

  // implements Message ----------------------------------------------

  ProcessInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessInfo& from);
  void MergeFrom(const ProcessInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string executable = 1;
  inline bool has_executable() const;
  inline void clear_executable();
  static const int kExecutableFieldNumber = 1;
  inline const ::std::string& executable() const;
  inline void set_executable(const ::std::string& value);
  inline void set_executable(const char* value);
  inline void set_executable(const char* value, size_t size);
  inline ::std::string* mutable_executable();
  inline ::std::string* release_executable();
  inline void set_allocated_executable(::std::string* executable);

  // required int32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // required bool is64bit = 3;
  inline bool has_is64bit() const;
  inline void clear_is64bit();
  static const int kIs64BitFieldNumber = 3;
  inline bool is64bit() const;
  inline void set_is64bit(bool value);

  // repeated uint64 thread_id = 4;
  inline int thread_id_size() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 4;
  inline ::google::protobuf::uint64 thread_id(int index) const;
  inline void set_thread_id(int index, ::google::protobuf::uint64 value);
  inline void add_thread_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      thread_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_thread_id();

  // @@protoc_insertion_point(class_scope:proto.ProcessInfo)
 private:
  inline void set_has_executable();
  inline void clear_has_executable();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_is64bit();
  inline void clear_has_is64bit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* executable_;
  ::google::protobuf::int32 pid_;
  bool is64bit_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > thread_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static ProcessInfo* default_instance_;
};
// -------------------------------------------------------------------

class FunctionArgument : public ::google::protobuf::Message {
 public:
  FunctionArgument();
  virtual ~FunctionArgument();

  FunctionArgument(const FunctionArgument& from);

  inline FunctionArgument& operator=(const FunctionArgument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionArgument& default_instance();

  void Swap(FunctionArgument* other);

  // implements Message ----------------------------------------------

  FunctionArgument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionArgument& from);
  void MergeFrom(const FunctionArgument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.DebugType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::DebugType type() const;
  inline void set_type(::proto::DebugType value);

  // required uint64 address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:proto.FunctionArgument)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 address_;
  ::std::string* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static FunctionArgument* default_instance_;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::Message {
 public:
  FunctionCall();
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionCall& default_instance();

  void Swap(FunctionCall* other);

  // implements Message ----------------------------------------------

  FunctionCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);

  // optional .proto.DebugType return_type = 3;
  inline bool has_return_type() const;
  inline void clear_return_type();
  static const int kReturnTypeFieldNumber = 3;
  inline ::proto::DebugType return_type() const;
  inline void set_return_type(::proto::DebugType value);

  // optional bytes return_data = 4;
  inline bool has_return_data() const;
  inline void clear_return_data();
  static const int kReturnDataFieldNumber = 4;
  inline const ::std::string& return_data() const;
  inline void set_return_data(const ::std::string& value);
  inline void set_return_data(const char* value);
  inline void set_return_data(const void* value, size_t size);
  inline ::std::string* mutable_return_data();
  inline ::std::string* release_return_data();
  inline void set_allocated_return_data(::std::string* return_data);

  // repeated .proto.FunctionArgument arguments = 5;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 5;
  inline const ::proto::FunctionArgument& arguments(int index) const;
  inline ::proto::FunctionArgument* mutable_arguments(int index);
  inline ::proto::FunctionArgument* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::FunctionArgument >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::FunctionArgument >*
      mutable_arguments();

  // @@protoc_insertion_point(class_scope:proto.FunctionCall)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_return_type();
  inline void clear_has_return_type();
  inline void set_has_return_data();
  inline void clear_has_return_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 thread_id_;
  ::std::string* return_data_;
  ::google::protobuf::RepeatedPtrField< ::proto::FunctionArgument > arguments_;
  int return_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static FunctionCall* default_instance_;
};
// -------------------------------------------------------------------

class GLFunction : public ::google::protobuf::Message {
 public:
  GLFunction();
  virtual ~GLFunction();

  GLFunction(const GLFunction& from);

  inline GLFunction& operator=(const GLFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GLFunction& default_instance();

  void Swap(GLFunction* other);

  // implements Message ----------------------------------------------

  GLFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GLFunction& from);
  void MergeFrom(const GLFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // required string extname = 2;
  inline bool has_extname() const;
  inline void clear_extname();
  static const int kExtnameFieldNumber = 2;
  inline const ::std::string& extname() const;
  inline void set_extname(const ::std::string& value);
  inline void set_extname(const char* value);
  inline void set_extname(const char* value, size_t size);
  inline ::std::string* mutable_extname();
  inline ::std::string* release_extname();
  inline void set_allocated_extname(::std::string* extname);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bool is_debuggable = 4;
  inline bool has_is_debuggable() const;
  inline void clear_is_debuggable();
  static const int kIsDebuggableFieldNumber = 4;
  inline bool is_debuggable() const;
  inline void set_is_debuggable(bool value);

  // required int32 primitive_mode_index = 5;
  inline bool has_primitive_mode_index() const;
  inline void clear_primitive_mode_index();
  static const int kPrimitiveModeIndexFieldNumber = 5;
  inline ::google::protobuf::int32 primitive_mode_index() const;
  inline void set_primitive_mode_index(::google::protobuf::int32 value);

  // required bool is_shader_switch = 6;
  inline bool has_is_shader_switch() const;
  inline void clear_is_shader_switch();
  static const int kIsShaderSwitchFieldNumber = 6;
  inline bool is_shader_switch() const;
  inline void set_is_shader_switch(bool value);

  // required bool is_frame_end = 7;
  inline bool has_is_frame_end() const;
  inline void clear_is_frame_end();
  static const int kIsFrameEndFieldNumber = 7;
  inline bool is_frame_end() const;
  inline void set_is_frame_end(bool value);

  // required bool is_framebuffer_change = 8;
  inline bool has_is_framebuffer_change() const;
  inline void clear_is_framebuffer_change();
  static const int kIsFramebufferChangeFieldNumber = 8;
  inline bool is_framebuffer_change() const;
  inline void set_is_framebuffer_change(bool value);

  // @@protoc_insertion_point(class_scope:proto.GLFunction)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_extname();
  inline void clear_has_extname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_is_debuggable();
  inline void clear_has_is_debuggable();
  inline void set_has_primitive_mode_index();
  inline void clear_has_primitive_mode_index();
  inline void set_has_is_shader_switch();
  inline void clear_has_is_shader_switch();
  inline void set_has_is_frame_end();
  inline void clear_has_is_frame_end();
  inline void set_has_is_framebuffer_change();
  inline void clear_has_is_framebuffer_change();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;
  ::std::string* extname_;
  ::std::string* name_;
  ::google::protobuf::int32 primitive_mode_index_;
  bool is_debuggable_;
  bool is_shader_switch_;
  bool is_frame_end_;
  bool is_framebuffer_change_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static GLFunction* default_instance_;
};
// -------------------------------------------------------------------

class GLFunctions : public ::google::protobuf::Message {
 public:
  GLFunctions();
  virtual ~GLFunctions();

  GLFunctions(const GLFunctions& from);

  inline GLFunctions& operator=(const GLFunctions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GLFunctions& default_instance();

  void Swap(GLFunctions* other);

  // implements Message ----------------------------------------------

  GLFunctions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GLFunctions& from);
  void MergeFrom(const GLFunctions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.GLFunction function = 1;
  inline int function_size() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 1;
  inline const ::proto::GLFunction& function(int index) const;
  inline ::proto::GLFunction* mutable_function(int index);
  inline ::proto::GLFunction* add_function();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::GLFunction >&
      function() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::GLFunction >*
      mutable_function();

  // @@protoc_insertion_point(class_scope:proto.GLFunctions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::GLFunction > function_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static GLFunctions* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  void Swap(ServerMessage* other);

  // implements Message ----------------------------------------------

  ServerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.ErrorCode error_code = 1 [default = NONE];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::proto::ErrorCode error_code() const;
  inline void set_error_code(::proto::ErrorCode value);

  // required uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // repeated .proto.FunctionCall function_call = 4;
  inline int function_call_size() const;
  inline void clear_function_call();
  static const int kFunctionCallFieldNumber = 4;
  inline const ::proto::FunctionCall& function_call(int index) const;
  inline ::proto::FunctionCall* mutable_function_call(int index);
  inline ::proto::FunctionCall* add_function_call();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::FunctionCall >&
      function_call() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::FunctionCall >*
      mutable_function_call();

  // optional .proto.GLFunctions gl_functions = 5;
  inline bool has_gl_functions() const;
  inline void clear_gl_functions();
  static const int kGlFunctionsFieldNumber = 5;
  inline const ::proto::GLFunctions& gl_functions() const;
  inline ::proto::GLFunctions* mutable_gl_functions();
  inline ::proto::GLFunctions* release_gl_functions();
  inline void set_allocated_gl_functions(::proto::GLFunctions* gl_functions);

  // optional .proto.ProcessInfo proc_info = 6;
  inline bool has_proc_info() const;
  inline void clear_proc_info();
  static const int kProcInfoFieldNumber = 6;
  inline const ::proto::ProcessInfo& proc_info() const;
  inline ::proto::ProcessInfo* mutable_proc_info();
  inline ::proto::ProcessInfo* release_proc_info();
  inline void set_allocated_proc_info(::proto::ProcessInfo* proc_info);

  // @@protoc_insertion_point(class_scope:proto.ServerMessage)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_gl_functions();
  inline void clear_has_gl_functions();
  inline void set_has_proc_info();
  inline void clear_has_proc_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* message_;
  ::google::protobuf::RepeatedPtrField< ::proto::FunctionCall > function_call_;
  ::proto::GLFunctions* gl_functions_;
  ::proto::ProcessInfo* proc_info_;
  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_debugger_2eproto();
  friend void protobuf_AssignDesc_debugger_2eproto();
  friend void protobuf_ShutdownFile_debugger_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Version

// required int32 major = 1;
inline bool Version::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline ::google::protobuf::int32 Version::major() const {
  return major_;
}
inline void Version::set_major(::google::protobuf::int32 value) {
  set_has_major();
  major_ = value;
}

// required int32 minor = 2;
inline bool Version::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Version::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Version::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline ::google::protobuf::int32 Version::minor() const {
  return minor_;
}
inline void Version::set_minor(::google::protobuf::int32 value) {
  set_has_minor();
  minor_ = value;
}

// required int32 revision = 3;
inline bool Version::has_revision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::set_has_revision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Version::clear_has_revision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Version::clear_revision() {
  revision_ = 0;
  clear_has_revision();
}
inline ::google::protobuf::int32 Version::revision() const {
  return revision_;
}
inline void Version::set_revision(::google::protobuf::int32 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// AnnounceDetails

// required int32 id = 1;
inline bool AnnounceDetails::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceDetails::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnounceDetails::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnounceDetails::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AnnounceDetails::id() const {
  return id_;
}
inline void AnnounceDetails::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string client_name = 2;
inline bool AnnounceDetails::has_client_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceDetails::set_has_client_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnounceDetails::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnounceDetails::clear_client_name() {
  if (client_name_ != &::google::protobuf::internal::kEmptyString) {
    client_name_->clear();
  }
  clear_has_client_name();
}
inline const ::std::string& AnnounceDetails::client_name() const {
  return *client_name_;
}
inline void AnnounceDetails::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::kEmptyString) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
}
inline void AnnounceDetails::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::kEmptyString) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
}
inline void AnnounceDetails::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::kEmptyString) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnnounceDetails::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::kEmptyString) {
    client_name_ = new ::std::string;
  }
  return client_name_;
}
inline ::std::string* AnnounceDetails::release_client_name() {
  clear_has_client_name();
  if (client_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AnnounceDetails::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != &::google::protobuf::internal::kEmptyString) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .proto.Version version = 3;
inline bool AnnounceDetails::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnnounceDetails::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnnounceDetails::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnnounceDetails::clear_version() {
  if (version_ != NULL) version_->::proto::Version::Clear();
  clear_has_version();
}
inline const ::proto::Version& AnnounceDetails::version() const {
  return version_ != NULL ? *version_ : *default_instance_->version_;
}
inline ::proto::Version* AnnounceDetails::mutable_version() {
  set_has_version();
  if (version_ == NULL) version_ = new ::proto::Version;
  return version_;
}
inline ::proto::Version* AnnounceDetails::release_version() {
  clear_has_version();
  ::proto::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline void AnnounceDetails::set_allocated_version(::proto::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    set_has_version();
  } else {
    clear_has_version();
  }
}

// -------------------------------------------------------------------

// ExecutionDetails

// required .proto.ExecutionDetails.Operation operation = 1;
inline bool ExecutionDetails::has_operation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutionDetails::set_has_operation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutionDetails::clear_has_operation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutionDetails::clear_operation() {
  operation_ = 0;
  clear_has_operation();
}
inline ::proto::ExecutionDetails_Operation ExecutionDetails::operation() const {
  return static_cast< ::proto::ExecutionDetails_Operation >(operation_);
}
inline void ExecutionDetails::set_operation(::proto::ExecutionDetails_Operation value) {
  assert(::proto::ExecutionDetails_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// optional .proto.FunctionCall call = 3;
inline bool ExecutionDetails::has_call() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutionDetails::set_has_call() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutionDetails::clear_has_call() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutionDetails::clear_call() {
  if (call_ != NULL) call_->::proto::FunctionCall::Clear();
  clear_has_call();
}
inline const ::proto::FunctionCall& ExecutionDetails::call() const {
  return call_ != NULL ? *call_ : *default_instance_->call_;
}
inline ::proto::FunctionCall* ExecutionDetails::mutable_call() {
  set_has_call();
  if (call_ == NULL) call_ = new ::proto::FunctionCall;
  return call_;
}
inline ::proto::FunctionCall* ExecutionDetails::release_call() {
  clear_has_call();
  ::proto::FunctionCall* temp = call_;
  call_ = NULL;
  return temp;
}
inline void ExecutionDetails::set_allocated_call(::proto::FunctionCall* call) {
  delete call_;
  call_ = call;
  if (call) {
    set_has_call();
  } else {
    clear_has_call();
  }
}

// -------------------------------------------------------------------

// DebugCommand

// required .proto.DebugCommand.Type type = 1;
inline bool DebugCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugCommand::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::proto::DebugCommand_Type DebugCommand::type() const {
  return static_cast< ::proto::DebugCommand_Type >(type_);
}
inline void DebugCommand::set_type(::proto::DebugCommand_Type value) {
  assert(::proto::DebugCommand_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ClientMessage

// required .proto.ClientMessage.Type type = 1;
inline bool ClientMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::ClientMessage_Type ClientMessage::type() const {
  return static_cast< ::proto::ClientMessage_Type >(type_);
}
inline void ClientMessage::set_type(::proto::ClientMessage_Type value) {
  assert(::proto::ClientMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint64 id = 2;
inline bool ClientMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ClientMessage::id() const {
  return id_;
}
inline void ClientMessage::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 thread_id = 3;
inline bool ClientMessage::has_thread_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_thread_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 ClientMessage::thread_id() const {
  return thread_id_;
}
inline void ClientMessage::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// optional .proto.AnnounceDetails announce = 4;
inline bool ClientMessage::has_announce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientMessage::set_has_announce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientMessage::clear_has_announce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientMessage::clear_announce() {
  if (announce_ != NULL) announce_->::proto::AnnounceDetails::Clear();
  clear_has_announce();
}
inline const ::proto::AnnounceDetails& ClientMessage::announce() const {
  return announce_ != NULL ? *announce_ : *default_instance_->announce_;
}
inline ::proto::AnnounceDetails* ClientMessage::mutable_announce() {
  set_has_announce();
  if (announce_ == NULL) announce_ = new ::proto::AnnounceDetails;
  return announce_;
}
inline ::proto::AnnounceDetails* ClientMessage::release_announce() {
  clear_has_announce();
  ::proto::AnnounceDetails* temp = announce_;
  announce_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_announce(::proto::AnnounceDetails* announce) {
  delete announce_;
  announce_ = announce;
  if (announce) {
    set_has_announce();
  } else {
    clear_has_announce();
  }
}

// optional .proto.ExecutionDetails execution = 5;
inline bool ClientMessage::has_execution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientMessage::set_has_execution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientMessage::clear_has_execution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientMessage::clear_execution() {
  if (execution_ != NULL) execution_->::proto::ExecutionDetails::Clear();
  clear_has_execution();
}
inline const ::proto::ExecutionDetails& ClientMessage::execution() const {
  return execution_ != NULL ? *execution_ : *default_instance_->execution_;
}
inline ::proto::ExecutionDetails* ClientMessage::mutable_execution() {
  set_has_execution();
  if (execution_ == NULL) execution_ = new ::proto::ExecutionDetails;
  return execution_;
}
inline ::proto::ExecutionDetails* ClientMessage::release_execution() {
  clear_has_execution();
  ::proto::ExecutionDetails* temp = execution_;
  execution_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_execution(::proto::ExecutionDetails* execution) {
  delete execution_;
  execution_ = execution;
  if (execution) {
    set_has_execution();
  } else {
    clear_has_execution();
  }
}

// optional .proto.DebugCommand command = 6;
inline bool ClientMessage::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientMessage::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientMessage::clear_command() {
  if (command_ != NULL) command_->::proto::DebugCommand::Clear();
  clear_has_command();
}
inline const ::proto::DebugCommand& ClientMessage::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::proto::DebugCommand* ClientMessage::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::proto::DebugCommand;
  return command_;
}
inline ::proto::DebugCommand* ClientMessage::release_command() {
  clear_has_command();
  ::proto::DebugCommand* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_command(::proto::DebugCommand* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// -------------------------------------------------------------------

// ProcessInfo

// required string executable = 1;
inline bool ProcessInfo::has_executable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessInfo::set_has_executable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessInfo::clear_has_executable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessInfo::clear_executable() {
  if (executable_ != &::google::protobuf::internal::kEmptyString) {
    executable_->clear();
  }
  clear_has_executable();
}
inline const ::std::string& ProcessInfo::executable() const {
  return *executable_;
}
inline void ProcessInfo::set_executable(const ::std::string& value) {
  set_has_executable();
  if (executable_ == &::google::protobuf::internal::kEmptyString) {
    executable_ = new ::std::string;
  }
  executable_->assign(value);
}
inline void ProcessInfo::set_executable(const char* value) {
  set_has_executable();
  if (executable_ == &::google::protobuf::internal::kEmptyString) {
    executable_ = new ::std::string;
  }
  executable_->assign(value);
}
inline void ProcessInfo::set_executable(const char* value, size_t size) {
  set_has_executable();
  if (executable_ == &::google::protobuf::internal::kEmptyString) {
    executable_ = new ::std::string;
  }
  executable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessInfo::mutable_executable() {
  set_has_executable();
  if (executable_ == &::google::protobuf::internal::kEmptyString) {
    executable_ = new ::std::string;
  }
  return executable_;
}
inline ::std::string* ProcessInfo::release_executable() {
  clear_has_executable();
  if (executable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executable_;
    executable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessInfo::set_allocated_executable(::std::string* executable) {
  if (executable_ != &::google::protobuf::internal::kEmptyString) {
    delete executable_;
  }
  if (executable) {
    set_has_executable();
    executable_ = executable;
  } else {
    clear_has_executable();
    executable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 pid = 2;
inline bool ProcessInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessInfo::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ProcessInfo::pid() const {
  return pid_;
}
inline void ProcessInfo::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// required bool is64bit = 3;
inline bool ProcessInfo::has_is64bit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessInfo::set_has_is64bit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessInfo::clear_has_is64bit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessInfo::clear_is64bit() {
  is64bit_ = false;
  clear_has_is64bit();
}
inline bool ProcessInfo::is64bit() const {
  return is64bit_;
}
inline void ProcessInfo::set_is64bit(bool value) {
  set_has_is64bit();
  is64bit_ = value;
}

// repeated uint64 thread_id = 4;
inline int ProcessInfo::thread_id_size() const {
  return thread_id_.size();
}
inline void ProcessInfo::clear_thread_id() {
  thread_id_.Clear();
}
inline ::google::protobuf::uint64 ProcessInfo::thread_id(int index) const {
  return thread_id_.Get(index);
}
inline void ProcessInfo::set_thread_id(int index, ::google::protobuf::uint64 value) {
  thread_id_.Set(index, value);
}
inline void ProcessInfo::add_thread_id(::google::protobuf::uint64 value) {
  thread_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ProcessInfo::thread_id() const {
  return thread_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ProcessInfo::mutable_thread_id() {
  return &thread_id_;
}

// -------------------------------------------------------------------

// FunctionArgument

// required .proto.DebugType type = 1;
inline bool FunctionArgument::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionArgument::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionArgument::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionArgument::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::DebugType FunctionArgument::type() const {
  return static_cast< ::proto::DebugType >(type_);
}
inline void FunctionArgument::set_type(::proto::DebugType value) {
  assert(::proto::DebugType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint64 address = 2;
inline bool FunctionArgument::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionArgument::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionArgument::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionArgument::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 FunctionArgument::address() const {
  return address_;
}
inline void FunctionArgument::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required bytes data = 3;
inline bool FunctionArgument::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionArgument::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionArgument::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionArgument::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& FunctionArgument::data() const {
  return *data_;
}
inline void FunctionArgument::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FunctionArgument::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FunctionArgument::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionArgument::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* FunctionArgument::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FunctionArgument::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FunctionCall

// required string name = 1;
inline bool FunctionCall::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionCall::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionCall::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionCall::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FunctionCall::name() const {
  return *name_;
}
inline void FunctionCall::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionCall::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionCall::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionCall::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FunctionCall::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FunctionCall::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 thread_id = 2;
inline bool FunctionCall::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionCall::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionCall::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionCall::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 FunctionCall::thread_id() const {
  return thread_id_;
}
inline void FunctionCall::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// optional .proto.DebugType return_type = 3;
inline bool FunctionCall::has_return_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionCall::set_has_return_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionCall::clear_has_return_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionCall::clear_return_type() {
  return_type_ = 0;
  clear_has_return_type();
}
inline ::proto::DebugType FunctionCall::return_type() const {
  return static_cast< ::proto::DebugType >(return_type_);
}
inline void FunctionCall::set_return_type(::proto::DebugType value) {
  assert(::proto::DebugType_IsValid(value));
  set_has_return_type();
  return_type_ = value;
}

// optional bytes return_data = 4;
inline bool FunctionCall::has_return_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FunctionCall::set_has_return_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FunctionCall::clear_has_return_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FunctionCall::clear_return_data() {
  if (return_data_ != &::google::protobuf::internal::kEmptyString) {
    return_data_->clear();
  }
  clear_has_return_data();
}
inline const ::std::string& FunctionCall::return_data() const {
  return *return_data_;
}
inline void FunctionCall::set_return_data(const ::std::string& value) {
  set_has_return_data();
  if (return_data_ == &::google::protobuf::internal::kEmptyString) {
    return_data_ = new ::std::string;
  }
  return_data_->assign(value);
}
inline void FunctionCall::set_return_data(const char* value) {
  set_has_return_data();
  if (return_data_ == &::google::protobuf::internal::kEmptyString) {
    return_data_ = new ::std::string;
  }
  return_data_->assign(value);
}
inline void FunctionCall::set_return_data(const void* value, size_t size) {
  set_has_return_data();
  if (return_data_ == &::google::protobuf::internal::kEmptyString) {
    return_data_ = new ::std::string;
  }
  return_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionCall::mutable_return_data() {
  set_has_return_data();
  if (return_data_ == &::google::protobuf::internal::kEmptyString) {
    return_data_ = new ::std::string;
  }
  return return_data_;
}
inline ::std::string* FunctionCall::release_return_data() {
  clear_has_return_data();
  if (return_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = return_data_;
    return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FunctionCall::set_allocated_return_data(::std::string* return_data) {
  if (return_data_ != &::google::protobuf::internal::kEmptyString) {
    delete return_data_;
  }
  if (return_data) {
    set_has_return_data();
    return_data_ = return_data;
  } else {
    clear_has_return_data();
    return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto.FunctionArgument arguments = 5;
inline int FunctionCall::arguments_size() const {
  return arguments_.size();
}
inline void FunctionCall::clear_arguments() {
  arguments_.Clear();
}
inline const ::proto::FunctionArgument& FunctionCall::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::proto::FunctionArgument* FunctionCall::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::proto::FunctionArgument* FunctionCall::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::FunctionArgument >&
FunctionCall::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::FunctionArgument >*
FunctionCall::mutable_arguments() {
  return &arguments_;
}

// -------------------------------------------------------------------

// GLFunction

// required string prefix = 1;
inline bool GLFunction::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLFunction::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLFunction::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLFunction::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& GLFunction::prefix() const {
  return *prefix_;
}
inline void GLFunction::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void GLFunction::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void GLFunction::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLFunction::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* GLFunction::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GLFunction::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string extname = 2;
inline bool GLFunction::has_extname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLFunction::set_has_extname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLFunction::clear_has_extname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLFunction::clear_extname() {
  if (extname_ != &::google::protobuf::internal::kEmptyString) {
    extname_->clear();
  }
  clear_has_extname();
}
inline const ::std::string& GLFunction::extname() const {
  return *extname_;
}
inline void GLFunction::set_extname(const ::std::string& value) {
  set_has_extname();
  if (extname_ == &::google::protobuf::internal::kEmptyString) {
    extname_ = new ::std::string;
  }
  extname_->assign(value);
}
inline void GLFunction::set_extname(const char* value) {
  set_has_extname();
  if (extname_ == &::google::protobuf::internal::kEmptyString) {
    extname_ = new ::std::string;
  }
  extname_->assign(value);
}
inline void GLFunction::set_extname(const char* value, size_t size) {
  set_has_extname();
  if (extname_ == &::google::protobuf::internal::kEmptyString) {
    extname_ = new ::std::string;
  }
  extname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLFunction::mutable_extname() {
  set_has_extname();
  if (extname_ == &::google::protobuf::internal::kEmptyString) {
    extname_ = new ::std::string;
  }
  return extname_;
}
inline ::std::string* GLFunction::release_extname() {
  clear_has_extname();
  if (extname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extname_;
    extname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GLFunction::set_allocated_extname(::std::string* extname) {
  if (extname_ != &::google::protobuf::internal::kEmptyString) {
    delete extname_;
  }
  if (extname) {
    set_has_extname();
    extname_ = extname;
  } else {
    clear_has_extname();
    extname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool GLFunction::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLFunction::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLFunction::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLFunction::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GLFunction::name() const {
  return *name_;
}
inline void GLFunction::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GLFunction::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GLFunction::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLFunction::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GLFunction::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GLFunction::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool is_debuggable = 4;
inline bool GLFunction::has_is_debuggable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLFunction::set_has_is_debuggable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLFunction::clear_has_is_debuggable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLFunction::clear_is_debuggable() {
  is_debuggable_ = false;
  clear_has_is_debuggable();
}
inline bool GLFunction::is_debuggable() const {
  return is_debuggable_;
}
inline void GLFunction::set_is_debuggable(bool value) {
  set_has_is_debuggable();
  is_debuggable_ = value;
}

// required int32 primitive_mode_index = 5;
inline bool GLFunction::has_primitive_mode_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLFunction::set_has_primitive_mode_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLFunction::clear_has_primitive_mode_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLFunction::clear_primitive_mode_index() {
  primitive_mode_index_ = 0;
  clear_has_primitive_mode_index();
}
inline ::google::protobuf::int32 GLFunction::primitive_mode_index() const {
  return primitive_mode_index_;
}
inline void GLFunction::set_primitive_mode_index(::google::protobuf::int32 value) {
  set_has_primitive_mode_index();
  primitive_mode_index_ = value;
}

// required bool is_shader_switch = 6;
inline bool GLFunction::has_is_shader_switch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLFunction::set_has_is_shader_switch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLFunction::clear_has_is_shader_switch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLFunction::clear_is_shader_switch() {
  is_shader_switch_ = false;
  clear_has_is_shader_switch();
}
inline bool GLFunction::is_shader_switch() const {
  return is_shader_switch_;
}
inline void GLFunction::set_is_shader_switch(bool value) {
  set_has_is_shader_switch();
  is_shader_switch_ = value;
}

// required bool is_frame_end = 7;
inline bool GLFunction::has_is_frame_end() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLFunction::set_has_is_frame_end() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLFunction::clear_has_is_frame_end() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLFunction::clear_is_frame_end() {
  is_frame_end_ = false;
  clear_has_is_frame_end();
}
inline bool GLFunction::is_frame_end() const {
  return is_frame_end_;
}
inline void GLFunction::set_is_frame_end(bool value) {
  set_has_is_frame_end();
  is_frame_end_ = value;
}

// required bool is_framebuffer_change = 8;
inline bool GLFunction::has_is_framebuffer_change() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLFunction::set_has_is_framebuffer_change() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLFunction::clear_has_is_framebuffer_change() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLFunction::clear_is_framebuffer_change() {
  is_framebuffer_change_ = false;
  clear_has_is_framebuffer_change();
}
inline bool GLFunction::is_framebuffer_change() const {
  return is_framebuffer_change_;
}
inline void GLFunction::set_is_framebuffer_change(bool value) {
  set_has_is_framebuffer_change();
  is_framebuffer_change_ = value;
}

// -------------------------------------------------------------------

// GLFunctions

// repeated .proto.GLFunction function = 1;
inline int GLFunctions::function_size() const {
  return function_.size();
}
inline void GLFunctions::clear_function() {
  function_.Clear();
}
inline const ::proto::GLFunction& GLFunctions::function(int index) const {
  return function_.Get(index);
}
inline ::proto::GLFunction* GLFunctions::mutable_function(int index) {
  return function_.Mutable(index);
}
inline ::proto::GLFunction* GLFunctions::add_function() {
  return function_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::GLFunction >&
GLFunctions::function() const {
  return function_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::GLFunction >*
GLFunctions::mutable_function() {
  return &function_;
}

// -------------------------------------------------------------------

// ServerMessage

// required .proto.ErrorCode error_code = 1 [default = NONE];
inline bool ServerMessage::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::proto::ErrorCode ServerMessage::error_code() const {
  return static_cast< ::proto::ErrorCode >(error_code_);
}
inline void ServerMessage::set_error_code(::proto::ErrorCode value) {
  assert(::proto::ErrorCode_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// required uint64 id = 2;
inline bool ServerMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ServerMessage::id() const {
  return id_;
}
inline void ServerMessage::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string message = 3;
inline bool ServerMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ServerMessage::message() const {
  return *message_;
}
inline void ServerMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ServerMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ServerMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ServerMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto.FunctionCall function_call = 4;
inline int ServerMessage::function_call_size() const {
  return function_call_.size();
}
inline void ServerMessage::clear_function_call() {
  function_call_.Clear();
}
inline const ::proto::FunctionCall& ServerMessage::function_call(int index) const {
  return function_call_.Get(index);
}
inline ::proto::FunctionCall* ServerMessage::mutable_function_call(int index) {
  return function_call_.Mutable(index);
}
inline ::proto::FunctionCall* ServerMessage::add_function_call() {
  return function_call_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::FunctionCall >&
ServerMessage::function_call() const {
  return function_call_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::FunctionCall >*
ServerMessage::mutable_function_call() {
  return &function_call_;
}

// optional .proto.GLFunctions gl_functions = 5;
inline bool ServerMessage::has_gl_functions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerMessage::set_has_gl_functions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerMessage::clear_has_gl_functions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerMessage::clear_gl_functions() {
  if (gl_functions_ != NULL) gl_functions_->::proto::GLFunctions::Clear();
  clear_has_gl_functions();
}
inline const ::proto::GLFunctions& ServerMessage::gl_functions() const {
  return gl_functions_ != NULL ? *gl_functions_ : *default_instance_->gl_functions_;
}
inline ::proto::GLFunctions* ServerMessage::mutable_gl_functions() {
  set_has_gl_functions();
  if (gl_functions_ == NULL) gl_functions_ = new ::proto::GLFunctions;
  return gl_functions_;
}
inline ::proto::GLFunctions* ServerMessage::release_gl_functions() {
  clear_has_gl_functions();
  ::proto::GLFunctions* temp = gl_functions_;
  gl_functions_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_gl_functions(::proto::GLFunctions* gl_functions) {
  delete gl_functions_;
  gl_functions_ = gl_functions;
  if (gl_functions) {
    set_has_gl_functions();
  } else {
    clear_has_gl_functions();
  }
}

// optional .proto.ProcessInfo proc_info = 6;
inline bool ServerMessage::has_proc_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerMessage::set_has_proc_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerMessage::clear_has_proc_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerMessage::clear_proc_info() {
  if (proc_info_ != NULL) proc_info_->::proto::ProcessInfo::Clear();
  clear_has_proc_info();
}
inline const ::proto::ProcessInfo& ServerMessage::proc_info() const {
  return proc_info_ != NULL ? *proc_info_ : *default_instance_->proc_info_;
}
inline ::proto::ProcessInfo* ServerMessage::mutable_proc_info() {
  set_has_proc_info();
  if (proc_info_ == NULL) proc_info_ = new ::proto::ProcessInfo;
  return proc_info_;
}
inline ::proto::ProcessInfo* ServerMessage::release_proc_info() {
  clear_has_proc_info();
  ::proto::ProcessInfo* temp = proc_info_;
  proc_info_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_proc_info(::proto::ProcessInfo* proc_info) {
  delete proc_info_;
  proc_info_ = proc_info;
  if (proc_info) {
    set_has_proc_info();
  } else {
    clear_has_proc_info();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ExecutionDetails_Operation>() {
  return ::proto::ExecutionDetails_Operation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::DebugCommand_Type>() {
  return ::proto::DebugCommand_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ClientMessage_Type>() {
  return ::proto::ClientMessage_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::DebugType>() {
  return ::proto::DebugType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ErrorCode>() {
  return ::proto::ErrorCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_debugger_2eproto__INCLUDED
